\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb,amscd,amsthm,xspace}
\usepackage[ngerman]{babel}
\usepackage{listingsutf8}
\usepackage{color}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{pst-tree}
\usepackage{algorithmic}
\usepackage{cancel}

\geometry{a4paper, left=2cm,right=2cm,top=2cm,bottom=2cm}

\newcommand{\Authors}{Martin Lenders (Di. 14-16), Ralf M\"uller-Zimmermann (Di. 14-16)}
\title{H\"ohere Algorithmik - 10. \"Ubungsblatt}
\author{\Authors}
\date{\today}

\newcommand{\changefont}[3]{\fontfamily{#1} \fontseries{#2} \fontshape{#3} \selectfont}

\renewcommand{\thesection}{Aufgabe \arabic{section}:}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumii}{(\theenumii)}
\renewcommand{\theenumii}{\roman{enumii}}

\definecolor{lgray}{gray}{0.95}
\definecolor{purple}{rgb}{0.498,0,0.3333}
\definecolor{identifier}{rgb}{0,0,0.1}
\definecolor{string}{rgb}{0.192,0,1}
\definecolor{comment}{rgb}{0.25,0.5,0.37}

\pagestyle{myheadings}
\oddsidemargin\oddsidemargin
\markright{\Authors}

\lstset{
	tabsize=4, 
	basicstyle=\footnotesize\fontfamily{pcr}\fontseries{m}\fontshape{n}\selectfont,
	breaklines=true,
	numbers=left,
	emphstyle=\textit, 
	language=Java,
	keywordstyle=\color{purple}\textbf, 
	identifierstyle=\color{identifier},
	stringstyle=\color{string},
	showstringspaces=false,
	escapeinside={((*}{*))},
	commentstyle=\color{comment},
	extendedchars=true,
	inputencoding=utf8/latin1
}
\psset{nodesep=2pt,levelsep=2em,treesep=2em}

\begin{document}

\maketitle

\section{Quake-Heaps: Details}
\subsection{Turnierbaum}
Quake-Heaps verwalten ihre Daten in Turnierbäumen. 
Um Quake-Heaps zu verstehen müssen wir also diese zunächst verstehen.
Turnierbäume sind balancierte Binärbäume (im Sinne, dass \emph{alle Blätter} den gleichen Abstand zur Wurzel haben und jeder Knoten maximal zwei Kinder hat) mit folgenden Eigenschaften:
\begin{itemize}
 \item Die Blätter verweisen via einen Schlüssel auf einen Wert.
 \item Das Minimum der Schlüssel seiner Kinder bestimmt den Schlüsselwert eines inneren Schlüssel.
 \item Alle Blätter haben einen Zeiger auf den höchsten Knoten im Baum, der den gleichen Schlüsselwert hat, wie das entsprechende Blatt.
\end{itemize}
Außerdem gelten für Turnierbäume folgende Operationen:
\begin{description}
\item[link($T_1$, $T_2$):]
    Verbindet zwei \emph{gleich hohe} Turnierbäume $T_1$ und $T_2$ zu einem neuen Turnierbaum. 
    Dazu werden die Wurzeln der beiden Bäume einfach als Kinder einer neuen Wurzel definiert und das Minimum der Schlüssel in die neue Wurzel geschrieben. 
    Der Zeiger des Blattes mit dem Schlüsselwert der neuen Wurzel wird die neue Wurzel umgebogen.
    Dies kann in konstanter Zeit $O(1)$ erledigt werden.
\item[cut($T$, $v$):]
    Schneiden einen Unterbaum aus einem Turnierbaum $T$, der dann den Knoten $v$ als neue Wurzel hat. 
    Der Schlüsselwert von $v$ muss sich dazu von seinem Elternknoten unterscheiden, damit die Turniebaumeigenschaften erhalten bleiben.
\end{description}

\subsection{Quake-Heaps}
Quake-Heaps bestehen aus einem Wald von Turnierbäumen, in deren Blättern entsprechend die Einträge des Quake-Heaps gespeichert sind und den Arrays $T$ und $n$.
$T[i]$ enthält eine Liste mit allen Bäumen der Tiefe $i$ und $n[i]$ eine Liste aller Knoten mit Höhe $i$.
Speichern wir die Tiefen der Bäume und Höhen der Knoten, können wir beide Arrays in $O(1)$ Zeit bei jeder Operation aktualisieren.
Außerdem müssen \emph{alle} Operationen folgende Invariante aufrechterhalten:
\[\forall i \geq 0{:}\ n[i+1] \leq \frac{3}{4} n[i]\]
Die Eigenschaften von Turnierbäumen gelten natürlich auch hier, womit alle inneren Knoten auf den kleinsten Schlüsselwert seiner Kinder.
Die bekannten Heap-Operationen \verb!insert!, \verb!decrease_key! und \verb!delete\_min! werden wie folgt implementiert.
\begin{description}
\item[insert($k$,$v$):]
    Fügt einen Wert $v$ unter dem Schlüssel $k$ dem Quake-Heap hinzu. Dazu wird lediglich ein neuer Baum mit einem Knoten, der als Blatt das Schlüssel-Wert-Paar speichert. 
    Die Laufzeit von \verb!insert! ist daher $O(1)$. 
    Rückgabewert dieser Operation ist ein Verweis auf das Blatt, in dem das Schlüssel-Wert-Paar gespeichert ist.
\item[decrease\_key($k$,$v$):]
    \emph{Verringert} den Schlüssel zum Wert $v$ auf $k$. Ist der Schlüssel zu $v$ bereits kleiner als $k$ ist diese Operation nicht zulässig.
    Optimaler Weise übergeben wir dabei gleich einen Verweis auf das Blatt (den uns \verb!insert! als Rückgabewert liefert).
    Wir schneiden nun mit \verb!cut(!$T$, $u$\verb!)! einen Unterbaum aus dem Turnierbaum $T$ ab, in dem das Blatt gespeichert ist, wobei $u$ der höchste Knoten ist, in dem der Schlüssel zu $v$ gespeichert ist.
    Dieser kann leicht gefunden werden, da das Blatt mit $v$ eine Verweis auf $u$ verwaltet.
    Nach dem Herausschneiden kann der Schlüssel verkleinert werden, da die Wurzel eines Turnierbaums immer auf den minimalen Schlüssel im Baum verweist und so die Turnierbaum-Eigenschaften erhalten bleiben.
    Die beiden entstandenen Bäume aus \verb!cut! werden dann im Wald des Heaps gespeichert.
\item[delete\_min():]
    Löscht das Element mit dem kleinsten Schlüssel aus dem Heap und gibt den entsprechenden Wert zurück.
    Wir durchsuchen zunächst alle Wurzeln des Waldes nach dem Minimum und löschen dessen Pfad, indem wir auf jeden Knoten von der Wurzel bis zu den Blättern, die den Schlüssel enthalten \verb!cut! aufrufen.
    Danach konsolidieren wir den Heap und stellen so sicher, dass nur jeweils ein Baum mit Tiefe $i$ existiert.
    \begin{algorithmic}
    \FOR{$t \in T$}
        \WHILE{$t > 1$}
            \STATE Wähle zwei Bäume $T_1, T_2$ aus $t$
            \STATE $T' \gets$\ \verb!link(!$T_1, T_2$\verb!)!
            \STATE $T[i+1] \gets$\ \verb!concat(!$T[i+1], [T']$\verb!)!
        \ENDWHILE
    \ENDFOR
    \end{algorithmic}
    Als letztes führen wir das namensgebende Beben (engl \emph{Quake}) aus, in dem wir die Sicherstellung der Invariante
    \[\forall i \geq 0{:}\ n[i+1] \leq \frac{3}{4} n[i]\]
    garantieren.
    \begin{algorithmic}
    \FOR{$i \in n.\operatorname{length}$}
        \IF{$n[i+1] > \dfrac{3}{4} n[i]$}
            \STATE Lösche alle Knoten mit Höhe > $i$
        \ENDIF
    \ENDFOR
    In den Turnierbäumen müssen dann natürlich noch die Zeiger der Blätter auf das höchste Blatt wieder aktualisiert werden.
    \end{algorithmic}
\end{description}

\section{Quake Heaps: Analyse}
\begin{enumerate}
\item   
\item   
\item   
\end{enumerate}

\section{Potentialfunktionen}
\begin{enumerate}
\item   
\item   
\item   
\end{enumerate}

\section{Potentialfunktionen}


\end{document}
