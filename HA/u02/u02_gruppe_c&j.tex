\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb,amscd,amsthm,xspace}
\usepackage[ngerman]{babel}
\usepackage{listingsutf8}
\usepackage{color}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{pst-tree}

\geometry{a4paper, left=2cm,right=2cm,top=2cm,bottom=2cm}

\newcommand{\Authors}{Christian Cikryt (Di. 14-16), Jakob Pfender (Mi. 14-16)}
\title{H\"ohere Algorithmik - 2. \"Ubungsblatt}
\author{\Authors}
\date{\today}

\newcommand{\changefont}[3]{\fontfamily{#1} \fontseries{#2} \fontshape{#3} \selectfont}

\renewcommand{\thesection}{Aufgabe \arabic{section}}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumii}{(\theenumii)}
\renewcommand{\theenumii}{\roman{enumii}}

\definecolor{lgray}{gray}{0.95}
\definecolor{purple}{rgb}{0.498,0,0.3333}
\definecolor{identifier}{rgb}{0,0,0.1}
\definecolor{string}{rgb}{0.192,0,1}
\definecolor{comment}{rgb}{0.25,0.5,0.37}

\pagestyle{myheadings}
\oddsidemargin\oddsidemargin
\markright{\Authors}

\lstset{
	tabsize=4, 
	frame=tlrb, 
	basicstyle=\footnotesize\changefont{pcr}{m}{n},
	breaklines=true,
	numbers=left,
	emphstyle=\textit, 
	language=Java,
	keywordstyle=\color{purple}\textbf, 
	identifierstyle=\color{identifier},
	stringstyle=\color{string},
	backgroundcolor=\color{lgray},
	showstringspaces=false,
	commentstyle=\color{comment},
	extendedchars=true,
	inputencoding=utf8/latin1
}
\psset{nodesep=2pt,levelsep=2em,treesep=2em}

\begin{document}

\maketitle

\section{Gewichteter Median}
\begin{enumerate}
\item	Gegeben eine Funktion \texttt{weighted\_median()}, die
	aus einer gegebenen Liste den gewichteten Median bestimmt,
	können wir einen einfachen Divide-and-Conquer-Algorithmus
	anwenden, um den Median zu finden:

	\begin{lstlisting}[numbers=none]
	int median(list) {
	  weighted_median = weighted_median(list);
	  smaller = [e | e <- list, e <= weighted_median];
	  larger  = [e | e <- list, e >  weighted_median];
	  if (size(smaller) > (size(list) / 2))
	    return median(smaller);
	  else if (size(smaller) == (size(list) / 2))
	    return weighted_median;
	  else
	    return median(larger);
	}
	\end{lstlisting}

	Für die Gewichtung kann man einfach jedem Element das Gewicht
	$1/n$ geben, wobei $n$ die Länge der Liste ist.

\item	Gegeben eine Liste mit $n$ gewichteten Elementen und eine
	Sortierfunktion \texttt{sort()}, können wir den gewichteten
	Median wie folgt bestimmen:

	\begin{lstlisting}[numbers=none]
	int weighted_median(list) {
	  sort(list);
	  weight = 0;
	  for (e : list) {
	    weight += e.weight;
	    if (weight > 0.5)
	      return e;
	  }
	}
	\end{lstlisting}

\item

\end{enumerate}

\section{Analyse des BFPRT-Algorithmus}

\section{Schmutzige Tricks mit dem Einheitskostenmaß}

\begin{enumerate}
\item   \renewcommand{\labelenumii}{(\theenumii)}
        \renewcommand{\theenumii}{\arabic{enumii}}
        \begin{enumerate} \newcommand{\lex}[1]{\ensuremath{\underset{\text{lex}}{#1}}}
        \item	$a = b \Leftrightarrow x = y$ ist trivial, da dann für
	alle $x_i, y_j$ gilt: $i = j \Leftrightarrow x_i = y_j$ und
	somit\\
                \[\sum\limits_{i=1}^{n} x_{i}u^{n-i+1} = \sum\limits_{i=1}^{n} y_{i}u^{n-i+1}\]
	\item	Ist $x$ lexikographisch kleiner als $y$, so gilt:
                \begin{align*}
                    \exists l \in \{1, ..., n\}{:}\ \forall k < l, k \in \{1, ..., n\}{:}\ x_k = y_k \land x_l < y_l 
                        &\Leftrightarrow \sum\limits_{i=1}^{n} x_{i}u^{n-i+1} < \sum\limits_{i=1}^{n} y_{i}u^{n-i+1}
                \end{align*}
		Wir können nun die Vektoren aufteilen, so dass wir
		insgesamt vier Vektoren $(x_1,...x_{l-1})$,
		$(x_l,...,x_n)$, $(y_1,...y_{l-1})$ und
		$(y_l,...,y_n)$ erhalten. Für $(x_1, ..., x_{l-1})$ und $(y_1, ..., y_{l-1})$ gilt 
                dann jeweils (1). Damit bleibt zu beweisen, dass
                \begin{align*}
                    x_l < y_l 
                        &\Leftrightarrow \sum\limits_{i=l}^{n} x_{i}u^{n-i+1} < \sum\limits_{i=l}^{n} y_{i}u^{n-i+1}.
                \end{align*}
		Somit ist zu beweisen, dass $x_l < y_l$ ausreicht, damit
		$a < b$ gilt. Das ist der Fall, wenn
                \[x_l u^{n-l+1} > \sum\limits_{i=l+1}^{n} x_{i}u^{n-i+1}\ \text{bzw.}\ y_l u^{n-l+1} > \sum\limits_{i=l+1}^{n} y_{i}u^{n-i+1}\].
                \begin{description}
                \item[Induktionsbehauptung] Für einen Vektor $(v_1,...,v_n)$ mit $0 \leq v_i \leq M$ gilt für $u > M$:
                        \[v_1 u^n > v_2 u^{n-1} + ... + v_n u\]
                \item[Induktionsvoraussetzung] Für einen Vektor $(v_1,...,v_{n-1})$ mit $0 \leq v_i \leq M$ gilt für $u > M$:
                        \[v_1 u^{n-1} > v_2 u^{n-2} + ... + v_{n-1} u\]
                \item[Induktionsanfang] $(n = 2)$
                        \begin{align*}
                         v_1 u^2 &> v_2 u & &\Longleftrightarrow& u^2 &> \frac{v_2 u}{v_1}
                        \end{align*}
                        Da $0 \leq v_1, v_2 < u$ (und $v_1, v_2 \in \mathbb{Z}$), ist das wahr. \hfill$\square$
                \item[Induktionsschritt]
                        \begin{align*}
                         v_1 u^n &> v_2 u^{n-1} + ... + v_n u \tag{IV + Transl. $>$}\\
                         v_1 u^n > v_2 u^{n-1} &> v_3 u^{n-2} + ... + v_n u\\
                         v_1 u^n &> v_2 n^{n-1} \tag{s. IA}
                        \end{align*}
                        \hfill$\square$
                \end{description}
                Damit ist bewiesen:
                \[(x_1, ..., x_n) \lex{<} (y_1, ..., y_n) 
                        \Leftrightarrow \sum\limits_{i=1}^{n} x_{i}u^{n-i+1} < \sum\limits_{i=1}^{n} y_{i}u^{n-i+1} \]
	\end{enumerate}

\end{enumerate}

\end{document}
