\documentclass[a4paper,10pt]{scrartcl}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsfonts,amssymb,amscd,amsthm,xspace}
\usepackage[ngerman]{babel}
\usepackage{listingsutf8}
\usepackage{color}
\usepackage{algorithmic}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{multicol}
\geometry{a4paper, left=2cm,right=2cm,top=2cm,bottom=2cm}

\newcommand{\Authors}{Christian Cikryt (Tut. Di. 14-16), Jakob Pfender (Mi. 14-16)}
\title{H\"ohere Algorithmik - 6. \"Ubungsblatt}
\author{\Authors}
\date{\today}

\newcommand{\changefont}[3]{\fontfamily{#1} \fontseries{#2} \fontshape{#3} \selectfont}

\renewcommand{\thesection}{Aufgabe \arabic{section}}
\renewcommand{\theenumi}{(\alph{enumi})}
\renewcommand{\theenumii}{(\roman{enumii}}

\definecolor{lgray}{gray}{0.95}
\definecolor{purple}{rgb}{0.498,0,0.3333}
\definecolor{identifier}{rgb}{0,0,0.1}
\definecolor{string}{rgb}{0.192,0,1}
\definecolor{comment}{rgb}{0.25,0.5,0.37}

\pagestyle{myheadings}
\oddsidemargin\oddsidemargin
\markright{\Authors}

\lstset{
	tabsize=4, 
	frame=tlrb, 
	basicstyle=\footnotesize\changefont{pcr}{m}{n},
	breaklines=true,
	numbers=left,
	emphstyle=\textit, 
	language=Java,
	keywordstyle=\color{purple}\textbf, 
	identifierstyle=\color{identifier},
	stringstyle=\color{string},
	backgroundcolor=\color{lgray},
	showstringspaces=false,
	commentstyle=\color{comment},
	extendedchars=true,
	inputencoding=utf8/latin1
}

\begin{document}

\maketitle

\section{Unabhängige Mengen in Pfaden}
\begin{enumerate}
 \item Sei $P = (V,E)$ ein Pfad mit Knoten $v_1, v_2, v_3$ und Gewichten
 $w_1 = 3$, $w_2 = 5$, $w_3 = 3$. Dann wählt der gierige Algorithmus im
 ersten Schritt $v_2$ als Knoten mit maximalem Gewicht und eliminiert
 dann $v_1$ und $v_3$, so dass die vom Algorithmus bestimmte unabhängige
 Menge nur aus $v_2$ besteht. Es ist aber trivial zu sehen, dass ${v_1,v_3}$ die
 maximale unabhängige Menge ist. Also
 arbeitet der Algorithmus nicht korrekt.
 \item Sei $P = (V,E)$ ein Pfad mit Knoten $v_1, v_2, v_3, v_4$ und
 Gewichten $w_1 = 3, w_2 = 2, w_3 = 1, w_4 = 3$. Dann gibt der
 Algorithmus ${v_2,v_4}$ als größte unabhängige Menge mit Gesamtgewicht
 5 zurück. Die maximale unabhängige Menge ist allerdings ${v_1,v_4}$ mit
 Gesamtgewicht 6.
 \item Sei $P = (V,E)$ ein Pfad mit Knoten $v_1, v_2, \hdots, v_n$ und entsprechenden Gewichten $w_1, w_2, \hdots, w_n$, dann gilt für das
  maximalen Gewicht einer unabhängigen Menge ($G(i)$) folgende Rekursionsgleichung, die über die Anzahl $i$ der Knoten geht:

  \begin{align*}
            G(1) &= w_1 \\
            G(2) &= \max\{w_1,w_2\} \\
            G(i) &= \max\{G(i-1), G(i-2) + w_i\} 
   \end{align*}
  Die Formeln für die Rekursionsanker gelten offensichtlich. Für ein $i > 2$ hat man die Wahl, entweder den $i$-ten Knoten mit in die Ergebnismenge aufzunehmen oder ihn nicht aufzunehmen.
  Falls man ihn aufnimmt, kann der $i-1$-te Knoten nicht gewählt werden, sondern frühestens der $i - 2$-te. Bei Nichtaufnahme kann auch der $i-1$-te Knote gewählt werden.
  Die Berechnung erfolgt nun durch dynamische Programmierung durch das Fülllen des Arrays $G[]$. Jedes Arrayelement besteht aus einem Tupel: 1. das maximale Gewicht, 2. die unabhängige Menge maximalen Gewichts.
  Mit \verb!first! und \verb!second! greift man auf das 1. bzw. 2. Element des Tupels zu.
\begin{algorithmic}
      \STATE $G[1] \gets (w[1], elem_1)$
      \IF{$w[1] > w[2]$}
	\STATE $G[2] \gets G[1]$
      \ELSE
	\STATE $G[2] \gets (w[2], elem_2)$
      \ENDIF
      \FOR{$i \in \{2, \hdots, n\}$}
	\IF{$G[i-1] > G[i - 2] + w[i]$}
	  \STATE $G[i] = G[i - 1]$
	\ELSE
	  \STATE $G[i] = (G[i - 2].first + w[i], G[i - 2].second + elem_i)$
	\ENDIF
    \ENDFOR
    \RETURN G[n]
  \end{algorithmic}
Die Laufzeit liegt in $O(n)$, da die for-Schleife über die n-Elemente des Arrays einmal läuft und in jedem Schritt nur konstant viel Kosten hat. Der Platzbedarf liegt genau genommen in $O(n^2)$,
da in jedem Eintrag $O(n)$-Elemente gespeichert werden und es $O(n)$-Elemente gibt. Den Platzbedarf könnte man falls kritisch auf $O(n)$ optimieren, indem man sich nur 2 aktuellsten Mengen merkt.
\end{enumerate}
\section{Vorlesungplanung}
\begin{enumerate}
 \item Gegenbeispiel (Algorithmus wählt rotmarkiertes, optimale Lösung grün markiert):
  \vfill

  \item
  \item Gegenbeispiel (Algorithmus wählt rotmarkiertes, optimale Lösung grün markiert):
 \vfill

\item Gegenbeispiel (Algorithmus wählt rotmarkiertes, optimale Lösung grün markiert):

 \vfill
\item Gegenbeispiel (Algorithmus wählt rotmarkiertes, optimale Lösung grün markiert):

 \vfill
\end{enumerate}

\end{document}
